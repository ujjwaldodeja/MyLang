package ut.pp.parser;

import ut.pp.SPRIL.*;

import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;

/**
 * Class Finalizer takes the list of instructions generated by program.toSpril and turns it into instructions
 * that are in a form for sprockell to understand.
 * Program.toSpril generates an intermediate representation of spril instructions where jump and branch instructions
 * contain pointers to other instructions instead of numeric values, and it can contain ForkPlaceHolderInstructions
 */
public class Finalizer {
    /**
     * Turn the intermediate representation code into sprockell instructions
     * @param instructionList list of instructions that will be modified
     */
    public static void finalizeCode(List<Instruction> instructionList) {
        // Replace any placeholder instruction with the instructions it represents
        replacePlaceHolders(instructionList);
        // Remove NOP instructions and update jump targetPtrs accordingly
        removeNOPs(instructionList);
        // Fix any chained jumps that can now exist
        removeJumpChains(instructionList);
        // Remove useless writes into memory
        removeUnusedLoadMemoryInstructions(instructionList);
        // Make jump targets absolute memory addresses
        finalizeJumpTargets(instructionList);
    }

    /**
     * Split any ForkPlaceholderInstruction object into Load and WriteInstr instructions
     * @param instructionList list of instructions that will be modified
     */
    private static void replacePlaceHolders(List<Instruction> instructionList) {
        ListIterator<Instruction> iter = instructionList.listIterator();
        while (iter.hasNext()) {
            Instruction nextInstr = iter.next();
            if (nextInstr instanceof ForkPlaceholderInstruction) {
                // remove placeholder
                iter.remove();
                // Get instructions for fork and add to instructionList
                List<Instruction> forkInstructions = ((ForkPlaceholderInstruction) nextInstr).getInstructions();
                for (Instruction forkInstr : forkInstructions) {
                    iter.add(forkInstr);
                }
            }
            else if (nextInstr instanceof BranchToErrorPlaceholderInstruction) {
                iter.remove();

                List<Instruction> branchInstruction = ((BranchToErrorPlaceholderInstruction) nextInstr).getInstructions();
                for (Instruction branchInstr: branchInstruction) {
                    iter.add(branchInstr);
                }
            }
        }
    }

    /**
     * Remove all NOP instructions and
     * make any jump instructions pointing to the NOP point to the next instruction instead
     * @param instructionList list of instructions that will be modified
     */
    private static void removeNOPs(List<Instruction> instructionList) {
        // Find NOPs and move TargetPtrs
        for (int i = 0; i < instructionList.size(); i++) {
            if (instructionList.get(i).getOpCode() == OpCode.NOP) {
                Instruction nopInstr = instructionList.get(i);
                Instruction nextInstr = instructionList.get(i+1);

                // Find any instruction that has the current NOP as jump / branch target
                for (Instruction instr : instructionList) {
                    if (instr.getJumpTargetPtr() == nopInstr) {
                        instr.setJumpTargetPtr(nextInstr);
                    }
                }
            }
        }

        // Remove all NOPs
        instructionList.removeIf(instr -> instr.getOpCode() == OpCode.NOP);
    }

    /**
     * After removing NOPs, a Jump can now target another Jump
     * To fix this, set all jumps to target the final Jump in the chain
     * Also, remove all jump statements that are on the next line from a jump statement, these are inaccessible after
     * removing the jump chain
     * @param instructionList list of instructions that will be modified
     */
    private static void removeJumpChains(List<Instruction> instructionList) {
        for (Instruction instr: instructionList) {

            // Check all Jump and Branch targets
            if (instr.getJumpTargetPtr() != null) {

                // Keep checking the next jump target and add all targets that point to a jump or branch to the list,
                // but only if the target itself is not a Branch instruction!
                List<Instruction> instructionsInChain = new ArrayList<>();
                instructionsInChain.add(instr);
                Instruction finalChainInstr = instr.getJumpTargetPtr();
                while (finalChainInstr.getOpCode() == OpCode.JUMP) {
                    instructionsInChain.add(finalChainInstr);
                    finalChainInstr = finalChainInstr.getJumpTargetPtr();
                }

                // Update jump and branch targets in the chain
                for (Instruction instrInChain : instructionsInChain) {
                    instrInChain.setJumpTargetPtr(finalChainInstr);
                }
            }
        }

        // After removing the jump chain, we can still have two sequential instructions that are both a jump,
        // the second jump is not reachable and can be removed
        ListIterator<Instruction> iter = instructionList.listIterator();
        Instruction curInstr = iter.next();
        while (iter.hasNext()) {
            Instruction prevInstr = curInstr;
            curInstr = iter.next();
            if (prevInstr.getOpCode() == OpCode.JUMP && curInstr.getOpCode() == OpCode.JUMP) {
                iter.remove();
            }
        }
    }

    /**
     * Change any jump or branch instructions that have a targetPtr as target argument
     * to have an (Abs [codeAddress]) argument instead
     * @param instructionList instruction list that will be modified
     */
    private static void finalizeJumpTargets(List<Instruction> instructionList) {
        for (Instruction instr: instructionList) {
            Instruction jumpTarget = instr.getJumpTargetPtr();
            if (jumpTarget != null) {
                // Find the index of the Jump Target instruction in the program
                int index = instructionList.indexOf(jumpTarget);
                // Set the jump target to an Absolute target
                instr.setJumpTargetAbs(index);
            }
        }
    }

    /**
     * Remove all Load instructions where we can be certain the memory location will not be read
     * @param instructionList list of instructions
     */
    public static void removeUnusedLoadMemoryInstructions(List<Instruction> instructionList) {
        // Find the maximum memory address in the program
        int maxAddress = 0;
        for (Instruction instr: instructionList) {
            Argument memAddrArg = null;
            if (instr.getOpCode() == OpCode.LOAD) {
                memAddrArg = instr.getArg(0);
            }
            else if (instr.getOpCode() == OpCode.STORE) {
                memAddrArg = instr.getArg(1);
            }

            if (memAddrArg instanceof DirAddr) {
                maxAddress = Math.max(maxAddress, ((DirAddr) memAddrArg).getAddress());
            }
        }

        // Set all memory locations as "not read from"
        List<Boolean> readFromLocation = new ArrayList<>();
        for (int i = 0; i <= maxAddress; i++) readFromLocation.add(false);

        // Keep a list of all instructions that can be removed
        List<Instruction> toBeRemoved = new ArrayList<>();

        // Go through the instruction list in reverse order
        for (int i = instructionList.size()-1; i >= 0; i--) {
            Instruction instr = instructionList.get(i);

            if (instr.getOpCode() == OpCode.LOAD) {
                Argument memAddrArg = instr.getArg(0);
                // When loading a memory location, set the readFromLocation value to true
                if (memAddrArg instanceof DirAddr) {
                    readFromLocation.set(((DirAddr) memAddrArg).getAddress(), true);
                }
                // When loading an indirect memory location, set all readFromLocation values to true, we might not know where is being read
                if (memAddrArg instanceof IndAddr) {
                    for (int a = 0; a <= maxAddress; a++) readFromLocation.set(a, true);
                }
            }
            else if (instr.getOpCode() == OpCode.STORE) {
                Argument memAddrArg = instr.getArg(1);
                // When storing to a memory location, set the readFromLocation value to false,
                // if it was already false, we can remove the Store instruction
                if (memAddrArg instanceof DirAddr) {
                    int memAddr = ((DirAddr) memAddrArg).getAddress();
                    if (readFromLocation.get(memAddr)) {
                        readFromLocation.set(memAddr, false);
                    }
                    else {
                        toBeRemoved.add(instr);
                        // Check if the previous instruction was meant to load the value into the variable, then we can remove it as well
                        if (i > 0) {
                            Instruction prevInstr = instructionList.get(i-1);
                            if (prevInstr.getOpCode() == OpCode.LOAD) {
                                String reg = ((RegAddr)prevInstr.getArg(1)).getReg();
                                if (reg.equals("regA")) toBeRemoved.add(prevInstr);
                            }
                        }

                    }
                }
                // If a value is stored into an indirect location, there is nothing safe to say about it, so we do nothing
            }
            else if (instr.getOpCode() == OpCode.JUMP || instr.getOpCode() == OpCode.BRANCH) {
                // We don't know what values are accessed after the jump, so we set all readFromLocation to true
                for (int a = 0; a <= maxAddress; a++) readFromLocation.set(a, true);
            }
        }

        // Remove unused instructions
        instructionList.removeAll(toBeRemoved);
    }

    /**
     * Turn a list of Instruction objects into a string containing the sprockell code.
     * Returns a string of form
     * [(Instruction 1)
     *      , (Instruction 2)       -- Potentially with comments like this
     *      , ...
     *      , (Instruction n)       ]
     * @param instructionList list of instructions
     * @return program code as String
     */
    public static String toProgramCode(List<Instruction> instructionList) {
        String prog = "[" + instructionList.get(0) + "\n";
        for (int i = 1; i < instructionList.size()-1; i++) {
            prog += "    , " + instructionList.get(i) + "\n";
        }
        prog += "    , " + instructionList.get(instructionList.size()-1) + "]\n";
        return prog;
    }

    /**
     * Turn a list of Instruction objects into a string with the instructions, with line numbers
     * Returns a string of form
     *   1: (Instruction 1)
     *   2: (instruction 2)     -- potentially with comments like this
     *   ...
     *   n: (instruction n)
     * @param instructionList list of instructions
     * @return formatted string with the list of instructions
     */
    public static String prettyPrint(List<Instruction> instructionList) {
        String pretty = "";
        for (int i = 0; i < instructionList.size(); i++) {
            pretty += String.format("%3d: %s\n", i, instructionList.get(i));
        }
        return pretty;
    }
}
